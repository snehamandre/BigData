{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Name: Sneha Mandrekar (824642241)\n",
    "Assignment: 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1. If we list all the natural numbers below 20 that are multiples of 3 or 5 but not multiples both of 3 and 5, we get 3, 5, 6, 9, 10, 12, 18. The sum of these multiples is 63. Write a function, sum_multiples_3_5, that returns the sum of the multiples of 3 and 5 less than N."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "def sum_multiples_3_5(N):\n",
    "    sum = 0;\n",
    "    \n",
    "    if type(N) != int or N < 0:\n",
    "        raise ValueError(\"INVALID INPUT: ARG-1 should be natural number\")\n",
    "    \n",
    "    for i in range(N):\n",
    "        if i % 3 == 0 or i % 5 == 0:\n",
    "            if i % 15 > 0:\n",
    "                sum += i\n",
    "    return sum    \n",
    "            "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "63"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum_multiples_3_5(20)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum_multiples_3_5(0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "128"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum_multiples_3_5(25)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be natural number\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    sum_multiples_3_5(\"20\")\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be natural number\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    sum_multiples_3_5(-120)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be natural number\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    sum_multiples_3_5(None)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be natural number\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    sum_multiples_3_5(True)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2. Write a function, pattern_count with two arguments. The first arguments is a string, lets call it text, and the second argument is also a string, call it pattern. The function pattern_count returns the number of times the pattern occurs in the text. \n",
    "pattern_count(“abababa”, “aba”) == 3\n",
    "pattern_count(“aaaaa”, “aa”) == 4\n",
    "pattern_count(“Abcde”, “abc”) == 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "def pattern_count(text, pattern):\n",
    "    \n",
    "    if not isinstance(text, str) or not isinstance(pattern, str):\n",
    "        raise ValueError(\"INVALID INPUT: Both inputs should be strings\")\n",
    "    \n",
    "    count, pattern_len, text_len = 0, len(pattern), len(text)\n",
    "    \n",
    "    if pattern_len > text_len:\n",
    "        raise ValueError(\"INVALID INPUT: Pattern length cannot be greater than text size\")\n",
    "    \n",
    "    for i in range(text_len - pattern_len + 1):\n",
    "        if text[i : i + pattern_len] == pattern:\n",
    "            count += 1\n",
    "    return count \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pattern_count(\"abababa\", \"aba\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pattern_count(\"aba\"\"baba\", \"aba\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "4"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pattern_count(\"aaaaa\", \"aa\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pattern_count(\"Abcde\", \"abc\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: Pattern length cannot be greater than text size\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    pattern_count(\"abc\", \"abcde\")\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: Both inputs should be strings\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    pattern_count(\"abababa\", 1)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: Both inputs should be strings\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    pattern_count(10, \"abc\")\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: Both inputs should be strings\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    pattern_count(None, \"abc\")\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3. A palindrome is a string that reads the same forwards and backwards. We will call a number octaldrome if its octal representation is a palindrome. So 945 is an octaldrome as in octal it is 1661. The first nine positive octaldromes are 1, 2, 3, 4, 5, 6, 7, 9 and 18. We want to find the n’th positive octaldrome. For example the 1’st positive octaldrome is 1, the fifth positive octaldrome is 5 and the eighth positive octaldrome is 9. Write a function nth_octaldrome(n) that returns the n’th positive octaldrome. So we have\n",
    "nth_octaldrome(1) ==1 \n",
    "nth_octaldrome(9) == 18."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "def nth_octaldrome(n):\n",
    "    \n",
    "    if type(n) != int or n <= 0:\n",
    "        raise ValueError(\"INVALID INPUT: ARG-1 should be postive integer\")\n",
    "    \n",
    "    count = 0;\n",
    "    octalDigits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"]\n",
    "    \n",
    "    i = 1\n",
    "    \n",
    "    while True:\n",
    "        octalStr, octalReverseStr, num = [], [], i\n",
    "        \n",
    "        while num > 0:\n",
    "            rem = num % 8\n",
    "            octalStr.insert(0, octalDigits[rem])\n",
    "            octalReverseStr.append(octalDigits[rem])\n",
    "            num = num // 8\n",
    "        \n",
    "        if octalStr == octalReverseStr:\n",
    "            count += 1\n",
    "            \n",
    "        if count == n:\n",
    "            return i\n",
    "        \n",
    "        i += 1\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "nth_octaldrome(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "18"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "nth_octaldrome(9)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be postive integer\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    nth_octaldrome(-9)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "8778"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "nth_octaldrome(200)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be postive integer\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    nth_octaldrome(\"abc\")\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be postive integer\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    nth_octaldrome(0)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be postive integer\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    nth_octaldrome(None)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be postive integer\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    nth_octaldrome(True)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "4. Write a function, most_frequent_word, which has two arguments. The first argument is a string, the second argument is an integer, call it n. most_frequent_word returns the sequence word(s) of length n that occurs most in the string. For example most_frequent_word(“TCGAAGCTAGACGCTAGTAGCTAGTGTGCA” 4) returns (“CTAG” “GCTA”)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "def most_frequent_word(text, n):\n",
    "    \n",
    "    if not isinstance(text, str):\n",
    "        raise ValueError(\"INVALID INPUT: ARG-1 should be string.\")\n",
    "    \n",
    "    if type(n) != int:\n",
    "        raise ValueError(\"INVALID INPUT: ARG-2 should be positive integer\")\n",
    "    \n",
    "    text_len = len(text)\n",
    "    \n",
    "    if n > text_len:\n",
    "        raise ValueError('INVALID INPUT: ARG-2 should not be greater than length of the text')\n",
    "    \n",
    "    word_to_count = {}\n",
    "    \n",
    "    for i in range(text_len - n + 1):\n",
    "        word = text[i : i + n]\n",
    "        if word in word_to_count.keys():\n",
    "            word_to_count[word] += 1\n",
    "        else:\n",
    "            word_to_count[word] = 1\n",
    "        \n",
    "    max_count = max(word_to_count.values()); \n",
    "    return [k for k,v in word_to_count.items() if v == max_count]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['GCTA', 'CTAG']"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "most_frequent_word(\"TCGAAGCTAGACGCTAGTAGCTAGTGTGCA\", 4)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['ABC', 'EFE']"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "most_frequent_word(\"ABCABCDDEFEFE\", 3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-2 should not be greater than length of the text\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    most_frequent_word(\"ab\", 5)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be string.\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    most_frequent_word(3, \"ABCABCDDEFEFE\")\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be string.\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    most_frequent_word(None, True)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "5. In DNA strings, symbols 'A' and 'T' are complements of each other, as are 'C' and 'G'. The reverse complement of a DNA string s is the string formed by reversing s, then taking the complement of each symbol (e.g., the reverse complement of \"GTCA\" is \"TGAC\"). Write a function reverse_complement(s) that returns thereverse complement of s."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "def reverse_complement(s):\n",
    "    \n",
    "    if not isinstance(s, str):\n",
    "        raise ValueError(\"INVALID INPUT: ARG-1 should be string\")\n",
    "    \n",
    "    dna_symbols = \"ACTG\"\n",
    "    \n",
    "    s = s.upper()\n",
    "    \n",
    "    for i in range(len(s)):\n",
    "        if s[i] not in dna_symbols:\n",
    "            raise ValueError(\"INVALID INPUT: ARG-1 should only contain \" + dna_symbols + \" chars\")\n",
    "\n",
    "    complement_list = []\n",
    "    for i in range(len(s)):\n",
    "        if s[i] == 'A':\n",
    "            complement_list.append('T')\n",
    "        elif s[i] == 'T':\n",
    "            complement_list.append('A')\n",
    "        elif s[i] == 'C':\n",
    "            complement_list.append('G') \n",
    "        elif s[i] == 'G':\n",
    "            complement_list.append('C')\n",
    "            \n",
    "    reverse_complement_str = ''.join(complement_list)\n",
    "    \n",
    "    return reverse_complement_str[::-1]\n",
    "        \n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'TGAC'"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reverse_complement(\"GTCA\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'TGAC'"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reverse_complement(\"gtca\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'CAGT'"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reverse_complement(\"ACTG\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should only contain ACTG chars\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    reverse_complement(\"abcd\")\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be string\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    reverse_complement(2)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be string\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    reverse_complement(None)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "6. The GC-content of a DNA string is given by the percentage of characters in the string that are 'C' or 'G'. For example, the GC-content of \"AGCTATAG\" is 37.5%. Write a function gc_content(s) with input a DNA-string and returns the GC-content of the string. So we have gc_content(\"AGCTATAG\") == 0.375"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "def gc_content(s):\n",
    "        \n",
    "    if not isinstance(s, str):\n",
    "        raise ValueError(\"INVALID INPUT: ARG-1 should be string\")\n",
    "    \n",
    "    dna_symbols, dna_str_len, gc_count = \"ACTG\", len(s), 0\n",
    "\n",
    "    s = s.upper()\n",
    "    \n",
    "    for i in range(len(s)):\n",
    "        if s[i] not in dna_symbols:\n",
    "            raise ValueError(\"INVALID INPUT: ARG-1 should only contain \" + dna_symbols + \" chars\")\n",
    "        \n",
    "        if s[i] in \"CG\":\n",
    "            gc_count += 1\n",
    "            \n",
    "    return gc_count / dna_str_len\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.375"
      ]
     },
     "execution_count": 41,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "gc_content(\"AGCTATAG\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.3"
      ]
     },
     "execution_count": 42,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "gc_content(\"AGCTATAGAT\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should only contain ACTG chars\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    gc_content(\"AGCTAMAGAT\")\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be string\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    gc_content(123)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT: ARG-1 should be string\n"
     ]
    }
   ],
   "source": [
    "try:  \n",
    "    gc_content(None)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "7. Write a function that receives a collection of strings and a map from strings to integers. Return a collection of integers that are values of the map corresponding to one of the strings in the collection. For example, given Array(\"Tom\", \"Fred\", \"Harry\") and Map(\"Tom\" -> 3, \"Dick\" -> 4, \"Harry\" -> 5), return Array(3, 5). (note the Array and Map here are pseudo-code to let you know the types"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_values(keys, key_values):\n",
    "    if keys == None or len(keys) == 0 or key_values == None or len(key_values) == 0:\n",
    "        raise ValueError(\"INVALID INPUT\")\n",
    "        return []\n",
    "    \n",
    "    if not isinstance(key_values, dict):\n",
    "        raise ValueError(\"INVALID INPUT : ARG-2 SHOULD BE A MAP\")\n",
    "        return []\n",
    "    \n",
    "    if not type(keys) in [list, set, tuple]:\n",
    "        raise ValueError(\"INVALID INPUT : ARG-2 SHOULD BE A List, or Set or Tuple\")\n",
    "        return []\n",
    "    \n",
    "    if not all(isinstance(i, str) for i in keys):\n",
    "        raise ValueError(\"INVALID DATA_TYPE IN ARG-1\")\n",
    "        return []\n",
    "\n",
    "    if not all(isinstance(k, str) for k in key_values):\n",
    "        raise ValueError(\"INVALID DATA_TYPE IN ARG-2\")\n",
    "        return []\n",
    "    \n",
    "    if not all(type(v) == int for v in key_values.values()):\n",
    "        raise ValueError(\"INVALID DATA_TYPE IN ARG-2\")\n",
    "        return []\n",
    "    \n",
    "    return [key_values[x] for x in keys]\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[1, 3]"
      ]
     },
     "execution_count": 47,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "students = {'John': 1, 'Robert': 2, 'Ned': 3}\n",
    "names = ['John', 'Ned']\n",
    "\n",
    "get_values(names, students)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID DATA_TYPE IN ARG-2\n"
     ]
    }
   ],
   "source": [
    "students = {'John': 1, 'Robert': 2, 'Ned': 3, 'Dany': 'd'}\n",
    "names = ['John', 'Ned']\n",
    "\n",
    "try:  \n",
    "    get_values(names, students)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID DATA_TYPE IN ARG-2\n"
     ]
    }
   ],
   "source": [
    "students = {'John': 1, 'Robert': 2, 'Ned': 3, 12: 4}\n",
    "names = ['John', 'Ned']\n",
    "\n",
    "try:  \n",
    "    get_values(names, students)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID DATA_TYPE IN ARG-1\n"
     ]
    }
   ],
   "source": [
    "students = {'John': 1, 'Robert': 2, 'Ned': 3, 'Dany': 4}\n",
    "names = ['John', 'Ned', 12]\n",
    "\n",
    "try:  \n",
    "    get_values(names, students)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1, 3]\n"
     ]
    }
   ],
   "source": [
    "students = {'John': 1, 'Robert': 2, 'Ned': 3, 'Dany': 4}\n",
    "names = ['John', 'Ned']\n",
    "\n",
    "try:  \n",
    "    print(get_values(names, students))\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INVALID INPUT : ARG-2 SHOULD BE A List, or Set or Tuple\n"
     ]
    }
   ],
   "source": [
    "students = {'John': 1, 'Robert': 2, 'Ned': 3, 'Dany': 4}\n",
    "names = 'John'\n",
    "\n",
    "try:  \n",
    "    get_values(names, students)\n",
    "except ValueError as e:\n",
    "    print (e)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Unit test cases for above functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "...."
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Running tests for gc_content ====\n",
      "=== Running tests for gc_content completed====\n",
      "=== Running tests for get_values ====\n",
      "=== Running tests for get_values completed====\n",
      "=== Running tests for most_frequent_word ====\n",
      "=== Running tests for most_frequent_word completed====\n",
      "=== Running tests for nth_octaldrome ====\n",
      "=== Running tests for nth_octaldrome completed====\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "..."
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Running tests for pattern_count ====\n",
      "=== Running tests for pattern_count completed====\n",
      "=== Running tests for reverse_complement ====\n",
      "=== Running tests for reverse_complement completed====\n",
      "=== Running tests for sum_multiples_3_5 ====\n",
      "=== Running tests for sum_multiples_3_5 completed====\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n",
      "----------------------------------------------------------------------\n",
      "Ran 7 tests in 0.009s\n",
      "\n",
      "OK\n"
     ]
    }
   ],
   "source": [
    "import unittest\n",
    "\n",
    "class Assignment1Tests(unittest.TestCase):\n",
    "\n",
    "    def test_sum_multiples_3_5(self):\n",
    "        print(\"=== Running tests for sum_multiples_3_5 ====\")\n",
    "        \n",
    "        self.assertEqual(sum_multiples_3_5(20), 63)\n",
    "        self.assertNotEqual(sum_multiples_3_5(20), 60)\n",
    "        \n",
    "        with self.assertRaises(Exception): sum_multiples_3_5(-120)\n",
    "        \n",
    "        print(\"=== Running tests for sum_multiples_3_5 completed====\")\n",
    "        \n",
    "    def test_pattern_count(self):\n",
    "        print(\"=== Running tests for pattern_count ====\")\n",
    "        \n",
    "        self.assertEqual(pattern_count(\"abababa\", \"aba\"), 3)\n",
    "        self.assertNotEqual(pattern_count(\"Abcde\", \"abc\"), 1)\n",
    "        with self.assertRaises(Exception): pattern_count(\"abc\", \"abcde\")\n",
    "        with self.assertRaises(Exception): pattern_count(\"abc\", None)\n",
    "        \n",
    "        print(\"=== Running tests for pattern_count completed====\")\n",
    "        \n",
    "    def test_nth_octaldrome(self):\n",
    "        print(\"=== Running tests for nth_octaldrome ====\")\n",
    "        \n",
    "        self.assertEqual(nth_octaldrome(8), 9)\n",
    "        self.assertNotEqual(nth_octaldrome(9), 9)\n",
    "        with self.assertRaises(Exception): nth_octaldrome(-9)\n",
    "        \n",
    "        print(\"=== Running tests for nth_octaldrome completed====\")\n",
    "        \n",
    "    def test_most_frequent_word(self):\n",
    "        print(\"=== Running tests for most_frequent_word ====\")\n",
    "        \n",
    "        most_frequent = most_frequent_word(\"TCGAAGCTAGACGCTAGTAGCTAGTGTGCA\", 4)\n",
    "        self.assertEqual(len(most_frequent), 2)\n",
    "        for word in most_frequent:\n",
    "            self.assertTrue(word == 'GCTA' or word == 'CTAG')\n",
    "            \n",
    "        with self.assertRaises(Exception): most_frequent_word(\"ab\", 5)\n",
    "        \n",
    "        print(\"=== Running tests for most_frequent_word completed====\")\n",
    "        \n",
    "    def test_reverse_complement(self):\n",
    "        print(\"=== Running tests for reverse_complement ====\")\n",
    "        \n",
    "        self.assertEqual(reverse_complement(\"GTCA\"), 'TGAC')\n",
    "        self.assertEqual(reverse_complement(\"gtca\"), 'TGAC')\n",
    "        with self.assertRaises(Exception): reverse_complement(\"abcd\")\n",
    "        \n",
    "        print(\"=== Running tests for reverse_complement completed====\")\n",
    "        \n",
    "    def test_gc_content(self):\n",
    "        print(\"=== Running tests for gc_content ====\")\n",
    "        \n",
    "        self.assertEqual(gc_content(\"AGCTATAG\"), 0.375)\n",
    "        self.assertEqual(gc_content(\"AGCTATAGAT\"), 0.3)\n",
    "        with self.assertRaises(Exception): gc_content(\"AGCTATAGZ\")\n",
    "        with self.assertRaises(Exception): gc_content(123)\n",
    "\n",
    "        print(\"=== Running tests for gc_content completed====\")\n",
    "        \n",
    "    def test_get_values(self):\n",
    "        print(\"=== Running tests for get_values ====\")\n",
    "        \n",
    "        values = get_values(['John', 'Ned'], {'John': 1, 'Robert': 2, 'Ned': 3})\n",
    "        self.assertEqual(len(values), 2)\n",
    "        for value in values:\n",
    "            self.assertTrue(value == 1 or value == 3)\n",
    "            \n",
    "        with self.assertRaises(Exception): get_values(['John', 'Ned'], {'John': 1, 'Robert': 2, 'Ned': 3, 'Dany' : 'd'})\n",
    "        with self.assertRaises(Exception): get_values(['John', 'Ned'], {'John': 1, 'Robert': 2, 'Ned': 3, 12 : 4})\n",
    "        with self.assertRaises(Exception): get_values('John', {'John': 1, 'Robert': 2, 'Ned': 3, 'Dany' : 4})\n",
    "        \n",
    "        print(\"=== Running tests for get_values completed====\")\n",
    "        \n",
    "\n",
    "if __name__ == '__main__':\n",
    "    unittest.main(argv=['first-arg-is-ignored'], exit=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
